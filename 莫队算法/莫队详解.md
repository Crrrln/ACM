## 莫队详解

参考博客：https://www.cnblogs.com/WAMonster/p/10118934.html


#### 前置知识：
1. 分块的基本思想（开根号等）
2. STL中sort的用法（手写cmp函数或重载运算符实现结构体的多关键字排序）
3. 基(du)础(liu)的卡常技巧（包含#pragma GCC optimize系列）
4. 倍增/树剖 求LCA（树上莫队所需）
5. 数值离散化（用于应付很多题目）

#### 分析

这题最简单做法无非暴力——用一个cnt数组记录每个数值出现的次数，再暴力枚举l到r统计次数，最后再扫一遍cnt数组，统计cnt不为零的数值个数，输出答案即可。设最大数值为s，那么这样做的复杂度为O(m(n+s))~O($n^{2}$)，对于本题实在跑不起。

我们可以尝试优化一下：
**优化1：** 每次枚举到一个数值num，增加出现次数时判断一下cntnum是否为0，如果为0，则这个数值之前没有出现过，现在出现了，数值数当然要+1。反之在从区间中删除num后也判断一下cntnum
是否为0，如果为0数值总数-1。这样我们优化掉了一个O(ms)，但还是跑不起。
**优化2：** 我们弄两个指针 l、r ，每次询问不直接枚举，而是移动 l、r 指针到询问的区间，直到[l,r]与询问区间重合。在统计答案时，我们也只在两个指针处加减cnt，然后我们就可以用优化1中的方法快速地统计答案啦qwq！

优化2具体步骤如下：
假设这个序列是这样子的：Q1、Q2是询问区间
![avater](https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214111957440-289670786.jpg)

![avatar](https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214112312924-142905583.jpg)

![avatar](https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214132130120-1554450961.jpg)

![avatar](https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214132211435-482551090.jpg)

![avatar](https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214132245702-439750869.jpg)


![avatar](https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214132450055-1521044095.jpg)

![avatar](https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214132530925-1512284326.jpg)


![avatar](https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214132620562-1439006141.jpg)


![avatar](https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214134652168-9341337.jpg)

![avatar](https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214134950911-245687742.jpg)

![avatar](https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214141945700-1377126698.jpg)

![avatar](https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214142409184-977743178.jpg)

![avatar](https://img2018.cnblogs.com/blog/1539583/201812/1539583-20181214142435118-121917103.jpg)