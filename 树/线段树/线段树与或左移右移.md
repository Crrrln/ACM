## 线段树区间与、或、左移、右移
[[位运算？位运算！](https://ac.nowcoder.com/acm/contest/211/E?&headNav=www)]

时间限制：C/C++ 3秒，空间限制：C/C++ 262144K

#### 题面
请实现一个数据结构支持以下操作：
**区间循环左右移，区间与，区间或，区间求和。**
(1 ≤ N,Q ≤ $ 2 * 10^{5} $ 0 ≤ ai < $2^{20}$)
对于00000000000000000101，右移一位后会变成100000000000000000102. 
不是区间位移，是区间中的每一个数的二进制位的位移

**输入：**
第一行n,q表示数列长度及操作次数。
第二行n个数表示初始序列。
接下来q行表示操作。
操作格式如下：一行表示一个操作。
所有操作形如 opt  l  r  v。
opt=1 表示将区间[l,r]循环右移v位。
opt=2 表示将区间[l,r]循环左移v位。
opt=3 表示将区间[l,r]按位或上v。
opt=4 表示将区间[l,r]按位与上v。
opt=5 询问区间[l,r]的和。
保证opt=1或2时 1 ≤ v ≤ 20
**注意：为了优化你的做题体验，操作5也会输入一个v，但是是没有意义的。
注意：循环左右移在20个二进制位的意义下进行**

**输出:**
对于每个opt=5的操作，输出一个数表示答案。


```cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define ls rt<<1
#define rs rt<<1|1

const int mac = 2e5 + 10;
const int nb = 20;

struct Tree
{
	int l, r;
	int sum[21], lazymove, lazytot[21];//lazymove代表位运算，lazytot代表或与运算
}tree[mac << 2];
int a[mac];

void push_up(int rt)
{
	for (int i = 0; i < nb; i++)
		tree[rt].sum[i] = tree[ls].sum[i] + tree[rs].sum[i];
}

void build(int rt,int l, int r)
{
	tree[rt].l = l, tree[rt].r = r;
	for (int i = 0; i < nb; i++)
		tree[rt].lazytot[i] = -1;
	if (l == r) {
		for (int i = 0; i < nb; i++)
			if (a[l] & (1 << i))
				tree[rt].sum[i] = 1;
		return;
	}
	int mid = (l + r) >> 1;
	build(ls, l, mid);
	build(rs, mid + 1, r);
	push_up(rt);
}

void pushdown(int rt)
{
	if (tree[rt].lazymove) {
		int p[21], ps[21], p1[21], ps1[21];
		for (int i = 0; i < nb; i++) {
			p[i] = tree[ls].sum[i]; p1[i] = tree[ls].lazytot[i];
			ps[i] = tree[rs].sum[i]; ps1[i] = tree[rs].lazytot[i];
		}
		tree[ls].lazymove += tree[rt].lazymove;
		tree[rs].lazymove += tree[rt].lazymove;
		for (int i = 0; i < nb; i++) {
			tree[ls].sum[i] = p[(i + tree[rt].lazymove) % nb];
			tree[rs].sum[i] = ps[(i + tree[rt].lazymove) % nb];
			tree[ls].lazytot[i] = p1[(i + tree[rt].lazymove) % nb];
			tree[rs].lazytot[i] = ps1[(i + tree[rt].lazymove) % nb];
		}
		tree[rt].lazymove = 0;
	}
	for (int i = 0; i < nb; i++) {
		if (tree[rt].lazytot[i] != -1) {
			tree[ls].sum[i] = (tree[ls].r - tree[ls].l + 1) * tree[rt].lazytot[i];
			tree[rs].sum[i] = (tree[rs].r - tree[rs].l + 1) * tree[rt].lazytot[i];
			tree[ls].lazytot[i] = tree[rt].lazytot[i];
			tree[rs].lazytot[i] = tree[rt].lazytot[i];
			tree[rt].lazytot[i] = -1;
		}
	}
}

void update(int rt, int L, int R, int val, int id)
{
	if (tree[rt].l >= L && tree[rt].r <= R) {
		if (id == 1) {//位移
			int tmpsum[21], tmptot[21];
			for (int i = 0; i < nb; i++)
				tmpsum[i] = tree[rt].sum[i], tmptot[i] = tree[rt].lazytot[i];
			for (int i = 0; i < nb; i++)
				tree[rt].sum[i] = tmpsum[(i + val) % nb], tree[rt].lazytot[i] = tmptot[(i + val) % nb];
			tree[rt].lazymove += val;
		}
		else if (id == 2)//或
			for (int i = 0; i < nb; i++)
			{
				if (val & (1 << i)) tree[rt].sum[i] = (tree[rt].r - tree[rt].l + 1), tree[rt].lazytot[i] = 1;
			}
		else//与
			for (int i = 0; i < nb; i++)
			{
				if (!(val & (1 << i))) tree[rt].sum[i] = 0, tree[rt].lazytot[i] = 0;
			}
		return;
	}
	pushdown(rt);
	int mid = (tree[rt].l + tree[rt].r) >> 1;
	if (mid >= L) update(ls, L, R, val, id);
	if (mid < R) update(rs, L, R, val, id);
	push_up(rt);
}

ll query(int rt, int L, int R)
{
	ll ans = 0;
	if (tree[rt].l >= L && tree[rt].r <= R) {
		for (int i = 0; i < nb; i++)
			ans += tree[rt].sum[i] * (1ll << i);
		return ans;
	}
	pushdown(rt);
	int mid = (tree[rt].l + tree[rt].r) >> 1;
	if (mid >= L) ans += query(ls, L, R);
	if (mid < R) ans += query(rs, L, R);
	return ans;
}

void in(int& x)
{
	int f = 0;
	char ch = getchar();
	while (ch > '9' || ch < '0') ch = getchar();
	while (ch >= '0' && ch <= '9') f = (f << 1) + (f << 3) + ch - '0', ch = getchar();
	x = f;
}

void print(ll x)
{
	if (x >= 10)
		print(x / 10);
	putchar(x % 10 + '0');
}

int main()
{
	int n, q;
	scanf("%d%d", &n, &q);
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	build(1, 1, n);
	while (q--) {
		int op, l, r, val;
		scanf("%d%d%d%d", &op, &l, &r, &val);
		if (op == 1)
			update(1, l, r, val, 1);//>>
		else if (op == 2)
			update(1, l, r, nb - val, 1);//<<
		else if (op == 3)
			update(1, l, r, val, 2);
		else if (op == 4)
			update(1, l, r, val, 3);
		else if (op == 5)
		{
			ll ans = query(1, l, r);
			printf("%lld\n", ans);
		}
	}
	return 0;
}


```