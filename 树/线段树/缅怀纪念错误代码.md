#### 题意：
n个节点两两相连，有三种操作：
D x：删除第x个节点
R  ：恢复刚刚删掉的节点
Q x：询问x节点所在连通块包含的节点个数

#### 思路：
  建立线段树1-n，删除一个节点x，向下跟新左子树为1-(x-1)，右子树(x+1)-n等。恢复的时候把左右子树删除，查询的时候，找到相应的节点，返回(r-l+1)即可。

#### 错误代码：

```cpp

#include<bits/stdc++.h>
using namespace std;
const int maxn=50010;
#define Lson(x) x<<1
#define Rson(x) x<<1|1
struct TREE
{
    int l,r;
    int sum;
    void update()
    {
        sum=r-l+1;
    }
}tree[maxn*10];

//建树
void build(int x,int l,int r,int num)
{
    if(num==-1)
    {

        tree[x].l=l,tree[x].r=r;
        tree[x].update();
        //printf("x=%d l=%d r=%d num=%d sum=%d\n",x,tree[x].l,tree[x].r,num,tree[x].sum);
        return;
    }
    if(tree[x].l<=num && tree[x].r>=num
       && (tree[Lson(x)].r==0 && tree[Rson(x)].l==0) )//如果num在l和r中间，并且下面还没有构建子节点
    {
        if(num==tree[x].l)
        {
            build(Rson(x),l+1,r,-1);
        }
        else if(num==tree[x].r)
        {
            build(Lson(x),l,r-1,-1);
        }
        else
        {
            build(Lson(x),l,num-1,-1);
            build(Rson(x),num+1,r,-1);
        }
    }
    else//往下找
    {
        if(num<=tree[Lson(x)].r)//num小于等于左子树的右节点
            build(Lson(x),tree[Lson(x)].l,tree[Lson(x)].r,num);
        else if(num>=tree[Rson(x)].l)//num大于等于右子树的左节点
            build(Rson(x),tree[Rson(x)].l,tree[Rson(x)].r,num);
    }
}

//查询
int query(int x,int num)
{
    if(num>=tree[x].l && num<=tree[x].r
       && (tree[Lson(x)].r==0&&tree[Rson(x)].l==0))//在范围内，且没有左右子树
    {
        return tree[x].sum;
    }

    if(num<=tree[Lson(x)].r && num>=tree[Lson(x)].l)//num在左子树
    {
        return query(Lson(x),num);
    }
    else if(num>=tree[Rson(x)].l && num<=tree[Rson(x)].r)//num在右子树
    {
        return query(Rson(x),num);
    }
    else//num被删除
        return 0;
}

//恢复
void rebuild(int x,int num)
{

    if(num-1==tree[Lson(x)].r || num+1==tree[Rson(x)].l)//num在左右子树中间，清空左右子树
    {
        tree[Lson(x)].l=tree[Lson(x)].r=0;
        tree[Rson(x)].l=tree[Rson(x)].r=0;
        tree[Lson(x)].update(),tree[Rson(x)].update();
        return;
    }
    else if(num<=tree[Lson(x)].r)//在左子树内
    {
        rebuild(Lson(x),num);
    }
    else if(num>=tree[Rson(x)].l)//在右子树内
    {
        rebuild(Rson(x),num);
    }
}

int n,m,num;
int vis[maxn];
char op;
stack<int> sta;
int main()
{
    while(~scanf("%d%d",&n,&m))
    {
        memset(vis,0,sizeof(vis));
        memset(tree,0,sizeof(tree));
        num=0;
        while(!sta.empty())
        {
            sta.pop();
        }
        build(1,1,n,-1);
        while(m--)
        {
            getchar();
            scanf("%c",&op);
            if(op=='D')//删除
            {
                scanf("%d",&num);
                if(vis[num])
                    continue;
                vis[num]=1;
                sta.push(num);
                build(1,1,n,num);
            }
            else if(op=='R')//恢复
            {
                if(sta.empty())
                    continue;
                num=sta.top();
                if(!vis[num])
                    continue;
                vis[num]=0;
                sta.pop();
                rebuild(1,num);
            }
            else//查询
            {
                scanf("%d",&num);
                printf("%d\n",query(1,num));
            }
        }
    }
    return 0;
}

```



#### 错误原因：
线段树是左右子树范围对半分，我这么分着建树，如果每次删除的都是边界的节点，向下建树最多得开$2 ^ {5000} $个节点，迟早会爆内存。