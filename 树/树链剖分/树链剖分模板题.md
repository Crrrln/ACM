## 树链剖分模板题
[[洛谷P3384]](https://www.luogu.org/problem/P3384)

**题意**
已知一棵包含N个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：
* 操作1： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z
* 操作2： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和
* 操作3： 格式： 3 x z 表示将以x为根节点的子树内所有节点值都加上z
* 操作4： 格式： 4 x 表示求以x为根节点的子树内所有节点值之和
(0< N,M < $10^5$)


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 10;//因为是无向边，所以开两倍
#define Lson(x) x<<1
#define Rson(x) x<<1|1
int head[maxn], cnt, num;//head[i]保存以i为初始节点所连的上一条边的编号
int father[maxn], son[maxn], dep[maxn], siz[maxn];//fa[u]存u的父亲节点，son[u]存点u连接的重儿子，dep[u]存u所在深度，siz[u]存u及他的子树的大小
int top[maxn], id[maxn], rk[maxn];//top[u]存点u所在链的顶端节点，id[u]存dfs遍历节点的顺序，rk[u]存顺序编号对应的节点编号
int n, m, r, p;//点数，操作数，根节点序号，取模数
int op, x, y, z, u, v;//操作
int a[maxn];

struct edge
{
	int to;
	int next;
}e[maxn << 1];

struct TREE
{
	int l, r;
	int ls, rs;
	int sum;
	int lazy;
	void update(int val)
	{
		lazy += val;
		sum += (r - l + 1) * val;
		sum%=p;
	}
}tree[maxn << 2];

//链式前向星添边
void add(int u, int v)
{
	e[cnt].to = v;
	e[cnt].next = head[u];
	head[u] = cnt++;
}

//------------------------------------线段树-----------------------------------------------

void push_up(int x)
{
	tree[x].sum = (tree[Lson(x)].sum + tree[Rson(x)].sum)%p;
}

void push_down(int x)
{
	int lazy = tree[x].lazy;
	if (!lazy)
		return;
	tree[Lson(x)].update(lazy);
	tree[Rson(x)].update(lazy);
	tree[x].lazy = 0;
}
//建树
void build(int x, int l, int r)
{
	tree[x].l = l, tree[x].r = r;
	if (l == r)
	{
		tree[x].sum = rk[l];//rk值为排好重链后的新顺序对应的值
		return;
	}
	int mid = (l + r) >> 1;
	build(Lson(x), l, mid);
	build(Rson(x), mid + 1, r);
	push_up(x);
}
//更新
void update(int x, int l, int r, int val)
{
	if (tree[x].l == l && tree[x].r == r)
	{
		tree[x].update(val);
		return;
	}
	push_down(x);
	int mid = (tree[x].l + tree[x].r) >> 1;
	if (r <= mid)
		update(Lson(x), l, r, val);
	else if (l > mid)
		update(Rson(x), l, r, val);
	else
	{
		update(Lson(x), l, mid, val);
		update(Rson(x), mid + 1, r, val);
	}
	push_up(x);
}
//查询
int query(int x, int l, int r)
{
	if (tree[x].l == l && tree[x].r == r)
	{
		return tree[x].sum % p;
	}
	push_down(x);
	int mid = (tree[x].l + tree[x].r) >> 1;
	if (r <= mid)
		return query(Lson(x), l, r) % p;
	else if (l > mid)
		return query(Rson(x), l, r) % p;
	else
		return (query(Lson(x), l, mid) % p + query(Rson(x), mid + 1, r) % p) % p;
}

//------------------------------------树链剖分-----------------------------------------------
//找重儿子
void dfs1(int u, int fa, int depth)//节点u，u的父节点，深度
{
    dep[u] = depth;
	father[u] = fa;
	siz[u] = 1;
	for (int i = head[u]; i!=-1 ; i = e[i].next)
	{
		int v = e[i].to;
		if (v == fa)
			continue;
		dfs1(v, u, depth + 1);
		siz[u] += siz[v];
		if (siz[son[u]] < siz[v])
			son[u] = v;
	}
}

//连接重边
void dfs2(int u, int t)//节点u，dfs时间戳，顶端节点t
{
	id[u] = ++num;
	rk[num] = a[u];//新编号对应权值
	top[u] = t;
	if(!son[u])//没有儿子时返回
        return;
    dfs2(son[u],t);//搜索下一个重儿子
	for (int i = head[u]; i != -1; i = e[i].next)
	{
		int v = e[i].to;
		if (v != father[u] && v != son[u])
			dfs2(v, v);//轻儿子的头节点为它自己
	}
}

//更新x到y最短路径上的值
void UpdatePath(int x, int y, int val)
{
	while (top[x] != top[y])//顶点不同
	{
		if (dep[top[x]] < dep[top[y]])//让x的深度更深
			swap(x, y);
		update(1, id[top[x]], id[x], val);//更新x到x的顶端
		x = father[top[x]];
	}
	if (dep[x] > dep[y])//让y的深度更深
		swap(x, y);
	update(1, id[x], id[y], val);
}

//查询x到y最短路径上的值
int QueryPath(int x, int y)
{
	int ans = 0;
	while (top[x] != top[y])
	{
		if (dep[top[x]] < dep[top[y]])//让x的深度更深
			swap(x, y);
		ans += query(1, id[top[x]], id[x]);
		ans %= p;
		x = father[top[x]];
	}
	if (dep[x] > dep[y])//让y的深度更深
		swap(x, y);
	ans += query(1, id[x], id[y]);
	ans %= p;
	return ans;
}

//跟新x及x的子树
void UpdateSonTree(int x, int val)
{
	update(1, id[x], id[x] + siz[x] - 1, val);
}

//查询x及x的子树
int QuerySonTree(int x)
{
	return query(1, id[x], id[x] + siz[x] - 1) % p;
}

int main()
{
	scanf("%d%d%d%d", &n, &m, &r, &p);
	memset(head, -1, sizeof(head));
	for (int i = 1; i <= n; i++)
	{
		scanf("%d", &a[i]);
	}
	for (int i = 1; i < n; i++)
	{
		scanf("%d%d", &u, &v);
		add(u, v);
		add(v, u);
	}
	dfs1(r, 0, 1);
	dfs2(r, r);//当前节点和根节点都是r
	build(1,1,n);//建树
	while (m--)
	{
		scanf("%d", &op);
		if (op == 1)//1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z
		{
			scanf("%d%d%d", &x, &y, &z);
			UpdatePath(x, y, z);
		}
		else if (op == 2)//2 x y 表示求树从x到y结点最短路径上所有节点的值之和
		{
			scanf("%d%d", &x, &y);
			printf("%d\n",QueryPath(x, y));
		}
		else if (op == 3)//3 x z 表示将以x为根节点的子树内所有节点值都加上z
		{
			scanf("%d%d", &x, &z);
			UpdateSonTree(x, z);
		}
		else//4 x 表示求以x为根节点的子树内所有节点值之和
		{
			scanf("%d", &x);
			printf("%d\n",QuerySonTree(x));
		}
	}
	return 0;
}

```